
# Chat Server 기능 구현 리스트

## 클라이언트와 서버가 통신하도록 한다

- 서버와 클라이언트는 TCP 소캣으로 통신한다.
- 서버를 실행하기 전에 Prot번호를 지정한다.
- server는 다음과 같이 실행 가능하다. 

```
$ python3 /path/server.py --port={port번호}
```


## 서버가 여러 클라이언트를 받을 수 있도록 대기한다.

- 서버는 I/O multiplexing으로 여러 클라이언트를 받을 수 있도록해야 한다. 


## 서버가 여러 클라이언트를 처리 할 수 있도록한다.

- 클라이언트와 상호작용은 workerthread가 처리한다.
- producer-consumer 문제에 유의 해야한다.


## json/proto 타입의 메시지를 받을 수 있도록한다.

- 메시지 타입에 따라 데이터를 처리한다.
- json과 proto타입에 맞춰 메시지를 전송한다.


## 서버 채팅 기능을 구현한다.

### client.py 명령어의 구현
앞에 나열한 client.py 명령어 중 `/help` 를 제외한 나머지는 모두 서버가 있어야 동작합니다.
각 명령어의 기대되는 동작은 다음과 같습니다.

### /name

* 클라이언트가 처음 연결되면 서버는 이 클라이언트에게 `(127.0.0.1, 9001)` 처럼 클라이언트 측 IP 주소와 port 번호를 이름으로 부여 합니다.
* `/name` 명령은 연결한 클라이언트의 닉네임을 변경합니다.
* 해당 클라이언트에게는 시스템 메시지로 `[시스템 메시지] 이름이 test 으로 변경되었습니다.` 와 같은 알림이 가야됩니다.
* 만일 이 클라이언트가 대화방에 들어가 있는 경우, 대화방에 있는 모든 멤버들에게 `[시스템 메시지] 이름이 test 으로 변경되었습니다.` 와 같은 메시지가 추가로 가야됩니다.

### /rooms

* 현재 개설된 대화방 목록이 출력됩니다.
* 대화방 목록은 (1) 방 번호, (2) 방 제목, (3) 참여중인 멤버들의 이름 이 나열되어야 됩니다.
* 위 정보가 포함되는한 출력 형식은 자유롭게 하면 됩니다.
* 개설된 대화방이 없는 경우 이를 알아볼 수 있게 자유롭게 표시하면 됩니다.

### /create

* 대화방을 개설하는 명령어로서, 뒤에 방제목을 입력해야 됩니다.
  예시: `/create hello world`
* 대화방 개설은 현재 참여 중인 대화방이 없는 경우만 가능해야됩니다. 만일 현재 다른 방에 들어가 있는 경우 서버는 `[시스템 메시지] 대화 방에 있을 때는 방을 개설 할 수 없습니다.` 메시지를 해당 유저에게 전송해야 됩니다.
* 대화방 개설과 동시에 해당 유저는 그 방에 자동으로 입장하게 됩니다.
  예시:
  ```
  /create hello world
  [시스템 메시지] 방제[hello world] 방에 입장했습니다.
  ```

### /join

* 이미 개설된 방에 참여할 수 있는 명령어로서, 뒤에 방 번호를 입력해야 됩니다.
  예시: `/join 2`
* 대화방 참여는 현재 참여중인 대화방이 없는 경우만 가능해야 됩니다. 만일 현재 다른 방에 들어가 있는 경우 서버는 `[시스템 메시지] 대화 방에 있을 때는 다른 방에 들어갈 수 없습니다.` 메시지를 해당 유저에게 전송해야 됩니다.
* 없는 방 번호의 방으로 들어가려고 할 때 서버는 `[시스템 메시지] 대화방이 존재하지 않습니다.` 메시지를 해당 유저에게 전송해야 됩니다.
* 방에 들어가면 서버는 해당 유저에게 `[시스템 메시지] 방제[hello world] 방에 입장했습니다.` 와 같은 메시지를 전송해야 됩니다.
* 방에 들어간 경우 모든 기존 멤버들에게는 `[시스템 메시지] [test2] 님이 입장했습니다.` 와 같은 메시지를 전송해야 됩니다.

### /leave

* 대화방을 나가는 명령어입니다.
* 대화방에 참여 중이지 않을 때 서버는 `[시스템 메시지] 현재 대화방에 들어가 있지 않습니다.` 메시지를 해당 유저에게 전송해야 됩니다.
* 남아있는 멤버들에게는 `[시스템 메시지] [test2] 님이 퇴장했습니다.` 와 같은 메시지가 전송 되어야 됩니다.
* 나간 유저 본인에게는 `[시스템 메시지] 방제[hello world] 대화 방에서 퇴장했습니다.` 와 같은 메시지를 전송해야 됩니다.

### /shutdown

* 채팅 서버를 종료하는 명령어입니다.
* 서버는 이 명령어를 수신하면 생성한 쓰레드들을 정리하고 프로그램을 종료해야 됩니다.

### 그밖에 입력

`/` 로 시작하지 않는 문자열은 채팅 메시지로 인식합니다.

* 만일 대화 방에 없는 경우 서버는 `[시스템 메시지] 현재 대화방에 들어가 있지 않습니다.` 를 해당 유저에게 전송해야 됩니다.
* 만일 대화 방에 있는 경우 해당 채팅 메시지는 본인을 제외한 나머지 모든 멤버들에게 전송되어야 합니다. 


# 아케택쳐 설계

## Reactor-Worker 패턴

검색해보니 요구사항에 알맞는 아키택쳐가 바로 Reactor-Worker 패턴으로 보인다.
Reactor가 클라이언트의 요청을 받아 (I/O Multiplexting) Worker에게 전달하고 Worker가 작업을 처리하는 것으로 보인다.

Reactor에서 TCP소캣으로 클라이언트로 요청을 비동기 I/O Multiplexing으로 수신하면 WorkerQueue에 전달하고
각 Worker는 WorkkerQueue에 있는 작업을 처리(소바)하는 형태가 될 것으로 추정된다.

필요에 따라 EventHandler, MessageBroker, ClientSession, ThreadPool을 구현한다.

정리하면 아래와 같이 구현하게 된다.

### Reactor : 이벤트 감지 및 분배
- I/O 이벤트를 감지하고 작업을 Worer에세 분배하는 역활을 수행한다.

### Worker : 작업 수행
- Reactor에서 분배된 작업을 처리한다.

### EventHandler: I/O 이벤트 처리
- Reactor가 I/O 이벤트를 감지 했을때 구체적인 어떤 작업을 수행할지 결정

### ClientSession: 클라이언트별 연결 관리
- 클라이언트간의 연결을 관리한다. 클라이언트가 서버에 접속할 때마다 개별적인 Client샤션을 생성하여 클라이언트 상태와 데이터를 보관한다.
- (필요 없는 경우 배제한다)

### MessageBroker: 메시지 전달 및 라우팅
- 클라이언트 간 메시지를 중개하거나, 특정 규칙에 따라 메시지를 라우팅 해야할 때

### ThreadPool : Thread 관리
- Worker 쓰레드를 생성, 모니터링, 종료 등을 쓰레드 관리를 담담한다.


