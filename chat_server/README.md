
# 프로그램 설명


### 서버 프로그램 실행 파일
/MJU-backend2024/chat_server/server

실행
```
$ server
```

### 아래는 서버 실행 옵션입니다.

서버 포트 번호 지정 (기본값=10114)
```
$ server --port=10114
```

서버 포맷 지정 (기본값=json)
```
$ server --port=json // 혹은 protobuf
```

Woker(thread)수 지정 (기본값=4)
```
$ server --worker=4 // 혹은 protobuf
```
<br>

```
## 참고 사항
// 원래는 MessageHandler 인터페이스를 만들고 
// 타입에 따라 Json OR Proto Handler를 객체를 설정한 뒤 handler proto, json 전부 통일하려 했으나
// (Strategy Pattern 혹은 Factory Pattern)
// 좀 그렇지만 디자인패턴 적용 안하고 메서드로만 분리했습니다. 
// (디자인 패턴 적용하기엔 요구사항에서 너무 벗어나는 것 같아서 두기로 했습니다)
```
<br>

### 자가진단표


- [✔️] worker thread 를 2개 이상으로 지정할 수 있도록 프로그래밍했는지 여부<br>
- [✔️] worker thread 가 2개 이상일 때 위의 명령어들이 제대로 동작하는지 여부 (= synchronization 이 제대로 구현되었는지)<br>
    - [✔️] /rooms<br>
    - [✔️] /nmae 방 안 밖 변경, 방에서 했을시 모두 공지<br>
    - [✔️] /create 생성하고 입장<br>
    - [✔️] /join 입장시 모두 알림<br>
    - [✔️] /leave 방나가기 및 모두 알림<br>
    - [✔️] /shutdown 서버 종료 (서버 종료까지 1초 이내 종료됨)<br>
- [✔️] 둘 이상의 채팅 방에 유저들이 나눠 들어가 있는 경우 대화방 간 간섭 없이 제대로 채팅이 되는지 여부<br>
- [✔️] I/O multiplexing 적용 여부<br>
- [✔️] producer-consumer 적용 여부 (= queue, mutex, condition variable 사용 여부)<br>
- [✔️] Message handler map 적용 여부<br>
- [✔️] JSON 과 Protobuf 둘 다 지원하는지 여부<br>

<br>

미구현 선택적 요구사항
- 방폭파
- 클라 종료시 방 맴버에게 공지 (방은 제대로 탈퇴됨)

<br>

# Chat Server 기능 구현 리스트 (메모)

## 클라이언트와 서버가 통신하도록 한다

- 서버와 클라이언트는 TCP 소캣으로 통신한다.
- 서버를 실행하기 전에 Prot번호를 지정한다.
- server는 다음과 같이 실행 가능하다. 

```
$ python3 /path/server.py --port={port번호}
```


## 서버가 여러 클라이언트를 받을 수 있도록 대기한다.

- 서버는 I/O multiplexing으로 여러 클라이언트를 받을 수 있도록해야 한다. 


## 서버가 여러 클라이언트를 처리 할 수 있도록한다.

- 클라이언트와 상호작용은 workerthread가 처리한다.
- producer-consumer 문제에 유의 해야한다.


## json/proto 타입의 메시지를 받을 수 있도록한다.

- 메시지 타입에 따라 데이터를 처리한다.
- json과 proto타입에 맞춰 메시지를 전송한다.


## 서버 채팅 기능을 구현한다.

### client.py 명령어의 구현
앞에 나열한 client.py 명령어 중 `/help` 를 제외한 나머지는 모두 서버가 있어야 동작합니다.
각 명령어의 기대되는 동작은 다음과 같습니다.

### /name

* 클라이언트가 처음 연결되면 서버는 이 클라이언트에게 `(127.0.0.1, 9001)` 처럼 클라이언트 측 IP 주소와 port 번호를 이름으로 부여 합니다.
* `/name` 명령은 연결한 클라이언트의 닉네임을 변경합니다.
* 해당 클라이언트에게는 시스템 메시지로 `[시스템 메시지] 이름이 test 으로 변경되었습니다.` 와 같은 알림이 가야됩니다.
* 만일 이 클라이언트가 대화방에 들어가 있는 경우, 대화방에 있는 모든 멤버들에게 `[시스템 메시지] 이름이 test 으로 변경되었습니다.` 와 같은 메시지가 추가로 가야됩니다.

### /rooms

* 현재 개설된 대화방 목록이 출력됩니다.
* 대화방 목록은 (1) 방 번호, (2) 방 제목, (3) 참여중인 멤버들의 이름 이 나열되어야 됩니다.
* 위 정보가 포함되는한 출력 형식은 자유롭게 하면 됩니다.
* 개설된 대화방이 없는 경우 이를 알아볼 수 있게 자유롭게 표시하면 됩니다.

### /create

* 대화방을 개설하는 명령어로서, 뒤에 방제목을 입력해야 됩니다.
  예시: `/create hello world`
* 대화방 개설은 현재 참여 중인 대화방이 없는 경우만 가능해야됩니다. 만일 현재 다른 방에 들어가 있는 경우 서버는 `[시스템 메시지] 대화 방에 있을 때는 방을 개설 할 수 없습니다.` 메시지를 해당 유저에게 전송해야 됩니다.
* 대화방 개설과 동시에 해당 유저는 그 방에 자동으로 입장하게 됩니다.
  예시:
  ```
  /create hello world
  [시스템 메시지] 방제[hello world] 방에 입장했습니다.
  ```

### /join

* 이미 개설된 방에 참여할 수 있는 명령어로서, 뒤에 방 번호를 입력해야 됩니다.
  예시: `/join 2`
* 대화방 참여는 현재 참여중인 대화방이 없는 경우만 가능해야 됩니다. 만일 현재 다른 방에 들어가 있는 경우 서버는 `[시스템 메시지] 대화 방에 있을 때는 다른 방에 들어갈 수 없습니다.` 메시지를 해당 유저에게 전송해야 됩니다.
* 없는 방 번호의 방으로 들어가려고 할 때 서버는 `[시스템 메시지] 대화방이 존재하지 않습니다.` 메시지를 해당 유저에게 전송해야 됩니다.
* 방에 들어가면 서버는 해당 유저에게 `[시스템 메시지] 방제[hello world] 방에 입장했습니다.` 와 같은 메시지를 전송해야 됩니다.
* 방에 들어간 경우 모든 기존 멤버들에게는 `[시스템 메시지] [test2] 님이 입장했습니다.` 와 같은 메시지를 전송해야 됩니다.

### /leave

* 대화방을 나가는 명령어입니다.
* 대화방에 참여 중이지 않을 때 서버는 `[시스템 메시지] 현재 대화방에 들어가 있지 않습니다.` 메시지를 해당 유저에게 전송해야 됩니다.
* 남아있는 멤버들에게는 `[시스템 메시지] [test2] 님이 퇴장했습니다.` 와 같은 메시지가 전송 되어야 됩니다.
* 나간 유저 본인에게는 `[시스템 메시지] 방제[hello world] 대화 방에서 퇴장했습니다.` 와 같은 메시지를 전송해야 됩니다.

### /shutdown

* 채팅 서버를 종료하는 명령어입니다.
* 서버는 이 명령어를 수신하면 생성한 쓰레드들을 정리하고 프로그램을 종료해야 됩니다.

### 그밖에 입력

`/` 로 시작하지 않는 문자열은 채팅 메시지로 인식합니다.

* 만일 대화 방에 없는 경우 서버는 `[시스템 메시지] 현재 대화방에 들어가 있지 않습니다.` 를 해당 유저에게 전송해야 됩니다.
* 만일 대화 방에 있는 경우 해당 채팅 메시지는 본인을 제외한 나머지 모든 멤버들에게 전송되어야 합니다. 


# 아케택쳐 설계

## Reactor-Worker 패턴

요구사항에 알맞는 아키택쳐가 바로 Reactor-Worker 패턴으로 보인다.
Reactor가 클라이언트의 요청을 받아 (I/O Multiplexting) Worker에게 전달하고 Worker가 작업을 처리할 예정이다.

Reactor에서 TCP소캣으로 클라이언트로 요청을 비동기 I/O Multiplexing으로 수신하면 WorkerQueue에 전달하고
각 Worker는 WorkkerQueue에 있는 작업을 처리(소바)하는 형태가 될 것이다.
EventHandler, ClientSession, ThreadPool을 구현한다.




코드 일부 GPT에 도움을 받아 작성 되었습니다.
(서버 시그널 종료, 코멘트 참석, 에러 검사 등)
